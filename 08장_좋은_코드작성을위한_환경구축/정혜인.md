## ESLint를 활용한 정적 분석 코드

- 버그와 예기치 못한 작동을 방지하기 위한 여러 가지 방법 중 빠르게 시도해볼 수 있는 방법은 **정적 코드 분석**이 있음
- **정적코드분석**: 코드의 실행과는 별개로 코드 그 자체만으로 코드 스멜(잠재적으로 버그를 야기할 수 있는 코드)을 찾아내어 문제의 소지가 있는 코드를 사전에 수정하는 것을 의미
- 자바스크립트 생태계에서 가장 많이 사용되는 정적 코드 분석 도구는 **ESLint**가 있음

### ESLint 살펴보기

- ESLint는 자바스크립트 코드를 정적 분석해 잠재적인 문제를 발견하고 나아가 수정까지 도와주는 도구이며, 코드를 분석하는 과정은 아래와 같이 요약할 수 있음
  1. 자바스크립트 코드를 문자열로 읽는다
  2. 자바스크립트 코드를 분석할 수 있는 파서(parser)로 코드를 구조화한다
  3. 2번에서 구조화한 트리를 AST(Abstract Syntax Tree)라 하며, 이 구조화된 트리를 기준으로 각종 규칙과 대조함
  4. 규칙과 대조했을 때 이를 위반한 코드를 알리거나(report) 수정한다(fix)
- 여기서 주목해야 할 것은 1번 과정에서 읽은 코드를 구조화하는 과정인 2번임. 자바스크립트를 분석하는 파서에는 여러 가지가 있는데, ESLint는 기본값으로 **espree**를 사용함
- `function hello(str) {}`라는 코드를 espress로 분석하면 아래와 같은 JSON 형태로 구조화된 결과를 얻을 수 있음
  ```json
  {
    "type": "Program",
    "start": 0,
    "end": 22,
    "range": [0, 22],
    "body": [
      {
        "type": "FuncionDeclaration",
        "start": 0,
        "end": 22,
        "range": [0, 22],
        "id": {
          "type": "Identifier",
          "start": 9,
          "end": 14,
          "range": [9, 14],
          "name": "hello"
        },
        "expression": false,
        "generator": false,
        "async": false,
        "params": [
          {
            "type": "identifier",
            "start": 15,
            "end": 18,
            "range": [15, 18],
            "name": "str"
          }
        ],
        "body": {
          "type": "BlockStatement",
          "start": 20,
          "end": 22,
          "range": [20, 22],
          "body": []
        }
      }
    ],
    "sourceType": "module"
  }
  ```
  - 단순히 한 줄밖에 안 되는 함수 내부 코드가 아무것도 없는 단순한 자바스크립트 코드임에도 불구하고 JSON으로 생성된 트리에 다양한 정보가 담겨 있음을 확인할 수 있음
  - espree 같은 코드 분석 도구는 단순히 변수인지, 함수인지, 함수명은 무엇인지 등만 파악하는 것이 아니라 코드의 정확한 위치와 같은 아주 세세한 정보도 분석해 알려줌
  - 이러한 자세한 정보가 있어야만 ESLint나 Prettier 같은 도구가 코드의 줄바꿈, 들여쓰기 등을 파악할 수 있게 됨
- ESLint가 espree로 코드를 분석할 결과를 바탕으로, 어떤 코드가 잘못된 코드이며 어떻게 수정해야 할지도 정해야 하는데, 이를 **ESLint 규칙(rules)**라고 하며 특정한 규칙의 모음을 **plugins**라고 함

### eslint-plugin과 eslint-config

- eslint-plugin과 eslint-config는 모두 ESLint와 관련된 패키지지만 각각의 역할이 다름

- **eslint-plugin**
  - eslint-plugin이라는 접두사로 시작하는 플러그인은 앞서 언급했던 규칙을 모아놓은 패키지임
  - eslint-plugin-import라는 패키지는 자바스크립트에서 다른 모듈을 불러오는 import와 관련된 다양한 규칙을 제공함
  - eslint-plugin-react는 리액트 관련 규칙을 제공하는 패키지로, JSX 배열에 키를 선언하지 않았다는 경고 메시지를 제공하기도 함
  - ESLint는 말 그대로 코드 정적 분석 도구라서 key가 유니크한 값인지까지는 확인해 줄 수 없지만 존재 여부만 확인해도 큰 도움을 받을 수 있음
- **eslint-config**
  - eslint-plugin이 리액트, import와 같이 특정 프레임워크나 도메인과 관련된 규칙을 묶어서 제공하는 패키지라면, eslint-config는 eslint-plugin을 한데 묶어서 완벽하게 한 세트로 제공하는 패키지라 할 수 있음
  - 여러 프로젝트에 걸쳐 동일하게 사용할 수 있는 ESLint 관련 설정을 제공하는 패키지라 할 수 있음
  - 내 입맛에 맞는 규칙을 모하 설치하고 적용하는 것도 좋지만 ESLint를 설정하는 것도 또한 만만치 않기 때문에 대부분의 경우 이미 존재하는 eslint-config를 설치해 빠르게 적용하는 경우가 일반적임
  - eslint-plugin 네이밍 규칙으로, eslint-config라는 **접두사를 준수**해야 하며, 반드시 **한 단어**로 구성해야함
  - 대표적인 라이브러리는 아래와 같이 존재함
    - eslint-config-airbnb
    - @titicaca/triple-config-kit
    - eslint-config-next

### 주의할 점

- **Prettier**와의 충돌
  - Prettier는 코드의 포매팅을 도와주는 도구로, ESLint와 마찬가지로 코드를 정적 분석해서 문제를 해결한다는 점을 동일하지만, 두 패키지가 지향하는 목표는 다름
  - ESLint는 코드의 잠재적인 문제가 될 수 있는 부분을 분석해 준다면, Prettier는 포매팅과 관련된 작업, 즉 줄바꿈, 들여쓰기, 작은따옴표와 큰따옴표 등을 담당함
  - 자바스크립트에서만 작동하는 ESLint와는 다르게, Prettier는 자바스크립트뿐만 아니라 HTML, CSS, 마크다운, JSON 등 다양한 언어에도 적용 가능한데 Prettier와 ESLint가 서로 충돌을 일으킬 수 있다는 문제점이 존재함
  - ESLint에서도 Prettier에서 처리하는 작업을 처리할 수 있기 때문에 두 가지 모두를 자바스크립트 코드에서 실행하면 서로 충돌하는 규칙으로 인해 에러가 발생하고, 최악의 경우 두가지 모두 만족하지 못하는 코드가 만들어질 수도 있음
  - 때문에 서로 규칙이 **충돌되지 않게끔 규칙을 잘 선언**하고, **자바스크립트나 타입스크립트는 ESLint에 그 외의 파일(마크다운, YAML, JSON 등)은 모두 Prettier에 맡기는 것**이 있음
- 규칙에 대한 예외 처리, 그리고 react-hooks/no-exhaustive-deps
  - 일부 코드에서 특정 규칙을 임시로 제외시키고 싶다면 `eslint-disalbe-주석`을 사용하면 됨. 특정 줄만 제외하거나, 파일 전체를 제외하거나, 특정 범위에 걸쳐 제외하는 것이 가능함
- ESLint 버전 충돌

## 리액트 팀이 권장하는 리액트 테스트 라이브러리

- **테스트**란 개발자가 만든 프로그램이 코딩을 한 의도대로 ㅈ가동하는지 확인하는 일련의 작업을 의미
- 테스트를 통해 개발자들은 처음에 설계한 대로 프로그램이 작동하는지 확인할 수 있고, 버그를 사전에 방지할 수도 있으며, 이후에 잘못된 작동으로 인해 발생하는 비용을 줄일 수도 있으며 이러한 일련의 테스트를 거친 프로그램은 사용자에게 버그가 최소화된 안정적인 서비스를 제공할 수 있는 원동력이 됨
- 백엔드의 테스트는 일반적으로 서버나 데이터베이스에서 원하는 데이터를 올바르게 가져올 수 있는지, 데이터 수정 간 교착 상태나 경쟁 상태가 발생하지는 않는지, 데이터 손실은 없는지, 특정 상황에서 장애가 발생하지 않는지 등을 확인하는 과정이 주를 이룸. 이러한 백엔드 테스트는 일반적으로 **화이트박스 테스트**로, 작성한 코드가 의도대로 작동하는지 확인해야 하며, 이는 GUI가 아닌 **AUI(Application User Interface: 응용 프로그램 사용자 인터페이스)**에서 주로 수행해야 하기 때문에 어느 정도 백엔드에 대한 이해가 있는 사람만 가능함
- 프론트엔드는 일반적인 사용자와 동일하거나 유사한 환경에서 수행됨. 사용자가 프로그램에서 수행할 주요 비즈니스 로직이나 모든 경우의 수를 고려해야 하며, 이 과정에서 사용자는 굳이 프론트엔드 코드를 알 필요는 없음. 즉, **블랙박스 형태**로 테스트가 이뤄지며, 코드가 어떻게 됐든 상관없이 의도한 대로 잘 작동하는지를 확인하는 데 좀 더 초점이 맞춰져 있음. 프론트엔드는 사용자에게 완전히 노출된 영역이므로 **어떻게 작동할지 최대한 예측해서 확인**해야 함. 사용자는 개발자의 의도대로만 사용하지 않기 때문임
- 프론트엔드 개발은 HTML, CSS와 같이 디자인 요소뿐만 아니라 사용자의 인터랙션, 의도치 않은 작동 등 브라우저에서 발생할 수 있는 다양한 시나리오를 고려해야 하기 때문에 일반적으로 테스팅하기가 매우 번거롭고 손이 많이 가서 테스팅 라이브러리도 상당히 다양한 편임. 단순히 함수나 컴포넌트 수준에서 유닛 테스트를 할 수도 있고, 사용자가 하는 작동을 모두 흉내 내서 테스트할 수도 있음

### React Testing Library란?

- DOM Testing Library를 기반으로 만들어진 테스팅 라이브러리로, 리액트를 기반으로 한 테스트를 수행하기 위해 만들어짐
- DOM Testing Library는 **jsdom**을 기반으로, 순수하게 자바스크립트로 작성된 라이브러리로 HTML이 없는 자바스크립트만 존재하는 환경에서 HTML과 DOM을 사용할 수 있도록 해주는 라이브러리임
- jsdom을 사용하면 자바스크립트 환경에서도 HTML을 사용할 수 있으므로 이를 기반으로 DOM Testing Library에서 제공하는 API를 사용해 테스트를 수행할 수 있음

### 자바스크립트 테스트의 기초

- 테스트 코드란 내가 작성한 코드가 내가 코드를 작성했던 당시의 의도와 목적에 맞는지 확인하는 코드를 의미함
- 기본적인 테스트 코드를 작성하는 방식은 아래와 같은 과정을 거침
  1. 테스트할 함수나 모듈을 선정한다
  2. 함수나 모듈이 반환하길 기대하는 값을 적는다
  3. 함수나 모듈의 실제 반환 값을 적는다
  4. 3번의 기대에 따라 2번의 결과가 일치하는지 확인한다
  5. 기대하는 결과를 반환한다면 테스트는 성공이며, 만약 기대와 다른 결과를 반환하면 에러를 던진다
- 이를 위해 가장 먼저 필요한 것이 ‘작성한 코드가 예상대로 작동한다면 성공했다는 메시지가 출력되고, 실패하면 에러를 던진다’라는 작동을 해주는 라이브러리가 필요한데, 다행히 Node.js는 assert라는 모듈을 기본적으로 제공하여 해당 모듈을 통해 위와 같이 작동하게 할 수 있음
- 일반적으로 테스트 코드와 실제 코드는 분리해서 작성함
- 테스트 결과를 확인할 수 있도록 도와주는 라이브러리를 어셜션(asssertion) 라이브러리라 함
- 테스트 코드는 가능한 한 사람이 읽기 쉽게, 그리고 테스트의 목적이 분명하게 작성되는 것이 중요함
- 이러한 테스트의 기승전결을 완성해주는 것이 바로 테스팅 프레임워크로 `Jest`, `Mocha`, `Karma`, `Jasmine`등이 있음

### 리액트 컴포넌트 테스트 코드 작성하기

- 기본적으로 리액트에서 컴포넌트 테스트는 아래와 같은 순서로 진행됨
  1. 컴포넌트를 렌더링한다
  2. 필요하다면 컴포넌트에서 특정 액션을 수행한다
  3. 컴포넌트 렌더링과 2번의 액션을 통해 기대하는 결과와 실제 결과를 비교한다

### 사용자 정의 훅 테스트하기

- `react-hooks-testing-library`를 활용하면 훅을 더욱 편리하게 테스트할 수 있음
- `useEffectDebugger`
  - 이 훅은 컴포넌트 명과 props를 인수로 받아 해당 컴포넌트가 어떤 props의 변경으로 인해 리렌더링됐는지 확인해 주는 일종의 디버거 역할을 하며, 훅이 구현할 기능은 아래와 같음
    - 최초 컴포넌트 렌더링 시에는 호출하지 않는다
    - 이전 props를 useRef에 저장해 두고, 새로운 props를 넘겨받을 때마다 이전 props와 비교해 무엇이 렌더링을 발생시켰는지 확인한다.
    - 이전 props와 신규 props의 비교는 리액트의 원리와 동일하게 Object.is를 활용해 **얕은 비교**를 수행한다
    - process.env.NODE_ENV == ‘production’인 경우에는 로깅을 하지 않는다. 이는 웹팩을 빌드 도구로 사용할 경우 일반적으로 트리쉐이킹이 이뤄지는 일종의 최적화 기법이다. 웹팩을 비롯한 많은 번들러에서는 process.enve.NODE_ENV === ‘production’인 경우에는 해당 코드가 빌드 결과물에 포함되지 않는다. 이는 운영 환경에서는 해당 코드가 실행되지 않는다는 의미다

### 테스트를 작성하기에 앞서 고려해야 할 점

- 테스트 커버리지가 높을수록 좋고 꾸준히 테스트 코드를 작성하는 것이지만, 테스트 커버리지가 만능은 아님
- 테스트 커버리지는 단순히 얼마나 많은 코드가 테스트되고 있는지를 나타내는 지표일 뿐, 테스트가 잘되고 있는지를 나타내는 것은 아니므로 절대 테스트 커버리지를 맹신해서는 안됨
- 프론트엔드 코드는 서버 코드와 다르게 사용자의 입력이 매우 자유롭기 때문에 모든 상황을 커버해 테스트를 작성하기란 불가능함
- 따라서 테스트 코드를 작성하기 전에 생각해 봐야 할 최우선 과제는 애플리케이션에서 가장 취약하거나 중요한 부분을 파악하는 것임

### 그 밖에 해볼 만한 여러 가지 테스트

- 유닛 테스트(Unit Test): 각각의 코드나 컴포넌트가 독립적으로 분리된 환경에서 의도된 대로 정확히 작동하는지 검증하는 테스트
- 통합 테스트(Integration Test): 유닛 테스트를 통과한 여러 컴포넌트가 묶여서 하나의 기능으로 정상적으로 작동하는지 확인하는 테스트
- 엔드 투 엔드(End To End Test): 흔히 E2E 테스트라 하며, 실제 사용자처럼 작동하는 로봇을 활용해 애플리케이션의 전체적인 기능을 확인하는 테스트
