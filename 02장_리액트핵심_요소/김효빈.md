# 02장

## 2.1 JSX란?

xml과 유사한 내장형 구문

ECMAscript라고 불리는 자바스크립트 표준의 일부는 아님

JSX는 자바스크립트 표준 코드가 아닌 페이스북이 임의로 만든 새로운 문법이기 때문에 반드시 트랜스파일러를 거쳐야 비로소 자바스크립트 런타임이 이해할 수 있는 의미 있는 자바스크립트 코드로 변환됨 

JSX 설계 목적은 다양한 트랜스파일러에서 다양한 속성을 가진 트리 구조를 토큰화해 ECMAScript로 변환하는 데 초점을 두고 있음 
JSX 내부에 트리 구조로 표현하고 싶은 다양한 것들을 작성해 두고 이 JSX를 트랜스파일이라는 과정을 거쳐 자바스크립트가 이해할 수 있는 코드로 변경하는 것이 목표
즉, JSX는 HTML, XML 이외에도 다른 구문으로도 확장될 수 있게끔 고려돼 있으며 최대한 구문을 간결하고 친숙하게 작성할 수 있도록 설계돼 있음
요약하자면 JSX는 자바스크립트 내부에서 표현하기 까다로웠던 XML 스타일의 트리 구문을 작성라는 데 많은 도움을 주는 새로운 문법

## 2.1.1 JSX의 정의

JSXElement, JSXAttribute, JSXChildren, JSXStrings라는4가지 컴포넌트를 기반으로 구성

JSXElement

JSX를 구성하는 기본 요소로 HTML의 기본 요소와 비슷한 역할

JSXElementName
JSXElement의 요소 이름으로 쓸 수 있는 것을 의미
JSXIdentifier 자바스크립트와 마찬가지로 숫자로 시작하거나 $, _ 외의 다른 측수 문자로는 시작할 수 없다

JSXNamespacedName 
JSXIdentifier: JSXIdentifier의 조합 즉, :을 통해 서로 다른 식별자를 이어주는 걱도 하나의 식별자로 취급됨 :로 묶을 수 있는 것은 한 개뿐

JSXMemberExpression JSXIdentifier.음

브라우저가 웹 사이트 접근 요청을 받고 화면을 그리는 과정에서 어떠한 일이 일어나는지

1. 브라우저가 사용자가 요청한 주소를 방문해 HTML 파일을 다운로드 한다
2. 브라우저의 렌더링 엔진은 HTML을 파싱해 DOM 노드로 구성된 트리(DOM)를 만든다
3. 2번 과정에서 CSS 파일을 만나면 해당 CSS 파일도 다운로드한다
4. 브라우저의 렌더링 엔진은 이 CSS도 파싱해 CSS 노드로 구성된 트리(CSSOM)를 만든다
5.브라우저는 2번에서 만든 DOM 노드를 순회하는데 여기서 모든 노드를 방문하는 것이 아니고 사용자 눈에 보이는 노드만 방문한다
즉, display: none과 같이 사용자 화면에 보이지 않는 요소는 방문해 작업하지 않는다 이는 트리를 분석하는 과정을 조금이라도 빠르게 하기 위해서다
6. 5번에서 제외된 눈에 보이는 노드를 대상으로 해당 노드에 대한 CSSOM 정보를 찾고 여기서 발견한 CSS 스타일 정보를 이 노드에 적용한다 이 DOM 노드에 CSS를 적용하는 과정은 크게 두 가지로 나눌 수 있다


## 2.2.2 가상 DOM의 탄생 배경

가상 DOM은 말 그대로 실제 브라우저의 DOM이 아닌 리액트가 관리하는 가상의 DOM을 의미한다. 

가상 DOM은 웹페이지가 표시해야 할 DOM을 일단 메모리에 저장하고 리액트가 실제 변경에 대한 준지가 완료됐을 때 실제 브라우저 DOM에 반영한다(여기서 얘기하는 리액트는 package.json에 있는 react가 아닌 react-dom을 의미)
이렇게 DOM 계산을 브라우저가 아닌 메모리에서 계산하는 과정을 한 번 거치게 된다먄 실제로는 여러 번 발생했을 렌더링 과정을 최소화할 수 있고 브라우저와 개발자의 부담을 덜 수 있음
가상 DOM이 일반적인 DOM을 관리하는 브라우저보다 빠르다는 사실은 오해, 무조건 빠른 것이 아니라 리액트의 이 가상  DOM은 대부분의 상황에서 웬만한 애플리케이션을 만들 정도로 충분히 빠르다는 것
리액트는 렌더링 방식에 있어서 브라우저와 개발자에게 도움을 줄 수 있는 가상 DOM 개념을 만즐었고 이는 애플리케이션을 개잘할 수 있을 만큼 핮리적으로 빠르기 때문에 채용했다고 보는 것이 옳음

## 2.2.3  가상 DOM을 위한 아키텍처, 리액트 파이버
가상 DOM과 렌더링 과정 최적화를 가능하게 해주는 것이 바로 리액트 파이버(React Fiber)

### 리액트 파이버란?
리액트에서 관리하는 평범한 자바스크립트 객체
파이버는 파이버 재조정자(fiber reconciler)가 관리하는데 가상 DOM과 실제 DOM을 비교해 변경 사항을 수집하며 이 둘 사이에 차이가 있으면 변경에 관련된 정보를 가지고 이는 파이버를 기준으로 화면 에 렌더링을 요청하는 역할을 한다.
재조정은 리액트에서 어떤 부분을 새롭게 랜더링해야 하는지 가상 DOM과 실제 DOM을 비교하는 작업(알고리즘)이라고 이해하면 됨

리액트 파이버의 목표는 리액트 웹 애플리케이션에서 발생하는 애니메이션, 레이아웃, 그리고 사용자 인터렉션에 올바른 결과물을 만드는 반응성을 문제를 해결하는 것

파이버는 다음과 같은 일을 함
작업을 작은 단위로 분할하고 쪼갠 다음, 우선순위를 매긴다.
이러한 작업을 일시 중지하고 나중에 다시 시작할 수 있다.
이전에 했던 작업을 다시 재사용하거나 필요하지 않은 경우에는 폐기할 수 있다

이러한 모든 과정이 비동기로 일어남
기존 랜더링 스택의 비효율성을 타파하기 위해 리액트 팀은 이 스택 조정자 대신 파이버라는 개념을 탄생

파이버는 일단 하나의 작업 단위로 구성돼 있음 리액트는 이러한 작업 단위를 하나씩 처리하고 finishedWork()라는 작업으로 마무리함
이 작업을 커밋해 실제 브라우저 DOM에 가시적인 변경 사항을 만들어 냄
1. 랜더 단계에서 리액트는 사용자에게 노출되지 않는 모든 비동기 작업을 수행함 그리고 이 단계에서 앞서 언급한 파이버의 작업, 우선순위를 지정하거나 중지시키거나 버리는 등의 작업이 일어남
2. 커밋 단계에서는 앞서 언급한 것처럼 DOM에 실제 변경 사항을 반영하기 위한 작업, commitWork()가 실행되는데, 이 과정은 앞서와 다르게 동기식으로 일어나고 중단될 수도 없음

리액트 요소는 랜더링이 발생할 때마다 새롭게 생성되자만 파이버는 가급적이면 재사용된다는 사실, 파이버는 컴포넌트가 최초로 마운트되는 시점에 생성되어 이후에는 가급적이면 재사용 됨

리액트 팀은 사실 리액트가 가상 DOM이 아닌 Value UI 즉 값을 가지고 있는 UI를 관리하는 라이브러리라는 내용을 피력한 바 있음 파이버의 객체 값에서도 알 수 있듯이 리액트의 핵심 원칙은 UI를 문자열, 숫자, 배열과 같은 값으로 관리한다는 것. 변수에 이러한 UI 관련 값을 보관하고 리액트의 자바스크립트 코드 흐름에 따라 이를 관리하고 표현하는 것이 바로 리액트

### 리액트 파이버 트리
파이버 트리는 사실 리액트 내부에서 두 개가 존재. 하나는 현재 모습을 담은 파이버 트리이고 다른 하나는 작업 중인 상태를 나타내는 workInProgress 트리. 리액트 파이버의 작업이 끝나면 리액트는 단순히 포인터만 변경해 workInProgress 트리를 현재 트리로 바꿔버림 이러한 기술을 더블 버퍼링이라 함

그래픽을 통해 표시되는 것을 그리기 위해서는 내부적으로 처리를 거쳐야 하는데 이러한 처리를 거치게 됨면 사용자에게 미처 다 그리지 못한 모습을 보는 경우가 발생하게 됨(한 번에 모든 작업을 마무리해 다음 그릴 수 없기 때문) 그래서 이러한 상황을 방지하기 위해 보이지 않는 곳에서 그 다음으로 그려야 할 그림을 미리 그린 다음 이것이 완성되면 현재 상태를 새로운 그림으로 바꾸는 기법을 의미

리액트에서도 이러한 더블 버퍼링 기법을 쓰는데 이러한 더블 버퍼링을 위해 트리가 두 개 존재
더블 버퍼링은 커밋 단계에서 수행됨
  
파이버의 작업 순서
과거의 동기식으로 처리했떤 트리 업데이트 과정, 재귀적으로 하나의 트리를 순회해 새로운 트리를 만드는 작업은 동기식이고 중단될 수 없었음 그러나 현재는 우선수위가 높은 다른 업데이트가 오면 현재 업데이트 자겁을 일시 중단하거나 새롭게 만들거나 폐기할 수도 있음 또한 작업 단위를 나누어 우선순위를 할당하는 것 또한 가능

## 2.2.4 파이버와 가상 DOM
파이버의 작동 방식과 알고리즘을 이해했다면 가상 DOM에 대해서도 이해하기 쉬워질 것
리액트 검포넌트에 대한 정보를 1:1로 가지고 있는 것이 파이버이며 이 파이버는 리액트 아키텍처 내부에서 비동기로 이뤄짐  

가상 DOM과 리액트의 핵심은 값으로 UI를 표현하는 것. 화면에 표시되는 UI를 자바스크립트의 문자열, 배열 등과 마찬가지로 값으로 관리하고 이러한 흐름을 효율적으로 관리하기 위한 메커니즘이 바로 리액트의 핵심

## 2.3 클래스형 컴포넌트와 함수형 컴포넌트
0.14 버전에 함수형 컴포넌트 소개됐을 때는 무상태 함수형 컴포넌트라고 해서 별도의 상태 없이 단순히 어떠한 요소를 정적으로 랜더링하는 것이 목적이었음
함수형 컴포넌트가 각광받기 시작한 것은 16.8 버전에서 훅이 소개된 이후였음
함수형 컴포넌트에 훅이 등장한 이후 함수형 컴포넌트에서 상태나 생명주기 메서드 비슷한 작업을 흉내낼 수 있게 되자 상대적으로 보일러플레이트가 복잡한 클래스형 컴포넌트보다 함수형 컴포넌트를 더 많이 쓰기 시작했음

## 2.3.1 클래스형 컴포넌트
```
import React from 'react'

class SampleComponent extends React.Component {
	render() {
		return <h2>Sample Component</h2>
	}
}
```

기본적으로 클래스형 컴포넌트를 만들려면 클래스를 선언하고 extends로 만들고 싶은 컴포넌트를 extends 해야함
extends 구문에 넣을 수 있는 클래스
	React. Component	
	React.PureComponent

메서드: 렌더링 함수 내부에서 사용되는 함수이며 보통 DOM에서 발생하는 이벤트와 함께 사용됨
constructor에서 this 바인드를 하는 방법 : 일반적인 함수로 메서드를 만든다면 this가 undefined로 나오는 현상을 겪게 될 것 따라서 생성된 함수에 bind를 활용해 강제로 this를 바인딩 해야함

화살표 함수를 쓰는 방법 : 실행 시점이 아닌 작성 시점에서 this가 상위 스코프로 결정되는 화살표 함수를 사용한다면 굳이 바인딩하지 않더라도 사용할 수 있음

렌더링 함수 내부에서 함수를 새롭게 만들어 전달하는 방법 : 메서드 내부에서 새롭게 함수를 만들어 전달
```
<button onClick={() => this.handleClick()}>증가</button>
```

그러나 이 방법을 사용하게 되면 매번 렌더링이 일어날 때마다 새로운 함수를 생성해서 할당하게 되므로 최적화를 수행하기가 매우 어려워짐 이 방법은 지양하는 것이 좋음

클래스형 컴포넌트의 생명주기 메서드

### 생명주기 메서드가 실행되는 시점은 크게 3가지로 나눌 수 있음
마운트(mount) : 컴포넌트가 마운트(생성)되는 시점
업데이트(update) : 이미 생성된 컴포넌트의 내용이 변경(업데이트)되는 시점
언마운트(unmount) : 컴포넌트가 더 이상 존재하지 않는 시점

각 생명주기 메서드
render()
render() 또한 생명주기 메서드 중 하나로 리액트 클래스형 컴포넌트의 유일한 필수 값으로 항상 쓰임. 컴포넌트가 UI를 렌더링하기 위해서 쓰임. 마운트와 업데이트 과정에서 일어남
이 render() 함수는 항상 순수해야 하며 부수 효과가 없어야 한다는 것. 즉 같은 입력값(props 또는 state)이 들어가면 항상 같은 결과물을 반환해야 한다는 뜻. 따라서 render() 내부에서 state를 직접 업데이트하는 this.setState를 호출해서는 안 됨. state를 변경하는 일은 클래스형 컴포넌트의 메서드나 다른 생명주기 메서드 내부에서 발생해야 함

componentDidMount()
클래스형 컴포넌트가 마운트되고 준비가 됐다면 그 다음으로 호출되는 생명주기 메서드가 바로 componentDidMount() 이 함수는 컴포넌트가 마운트되고 준비되는 즉시 실행됨
render()와 다르게 이 함수 내부에서는 this.setState()로 state 값을 변경하는 것이 가능함
this.setState를 호출했다면 state가 변경되고 그리고 그 즉시 다시 한 번 렌더링을 시도하는데 이 작업은 실제로 UI를 업데이트 하기 전에 실행되어 사용자가 변경되는 것을 눈치챌 수 없게 만듦
일반적으로 state를 다루는 것은 생성자에서 하는 것이 좋음

 componentDidUpdate()
컴포넌트 업데이트가 일어난 이후 바로 실행됨 일반적으로 state나 props의 변화에 따라 DOM을 업데이트하는 등에 쓰임 여기서도 this.setState를 사용할 수 있음
그러나 적절한 조건문으로 감싸지 않는다면 this.setState가 계속해서 호출되는 일이 발생할 수 있음

componentWillUnmount()
이 생명주기 메서드는 컴포넌트가 언마운트되거나 더 이상 사용되지 않기 직전에 호출됨
메모리 누수나 불필요한 작동을 막기 위한 클린업 함수를 호출하기 위한 최적의 위치
이 메서드 내에서는 this.setState를 호출할 수 없음
API 호출을 취소하거나 setInterval, setTimeout으로 생성된 타이머를 지우는 등의 작업에 유용

shouldComponentUpdate()
state나 props의 변경으로 리액트 컴포넌트가 다시 리렌더링 되는 것을 막고 싶다면 이 생명주기 메서드를 사용하면 됨
일반적으로 state 변화에 따라 컴포넌트가 리렌더링되는 것은 굉장히 자연스러운 일이므로 이 메서드를 사용하는 것은 특정한 성능 최적화 상황에서만 고려해야 함

Component와 pureComponent의 차이점은 생명주기를 다루는 데 있음
PureComponent는 state 값에 대해 얕은 비교를 수행해 결과가 다를 때만 렌더링을 수행함
PureComponent는 필요한 곳에 적재적소에 활용하는 것이 애플리케이션에 도움이 됨

static getDerivedStateFromPorps()
이제는 사라진 componenteWillReceiveProps를 대체할 수 있는 메서드
이 메서드는 render()를 호출하기 직전에 호출됨
static으로 선언돼 있어 this에 접근할 수 없다는 것, 여기서 반환하는 객체는 해당 객체의 내용이 모두 state로 들어가게 됨 이에 반해 null을 반환하면 아무런 일도 일어나지 않음
이 메서드도 모든 render() 실행 시에 호출된다는 점

getSnapShotBeforeUpdate()
componentWillUpdate()를 대체할 수 있는 메서드
이는 DOM이 업데이트 되기 직전에 호출됨, 여기서 반환되는 값은 componentDidUpdate로 전달됨. DOM에 렌더링 되기 전에 윈도우 크기를 조절하거나 스크롤 위치를 조정하는 등의 작업을 처리하는 데 유용

getDerivedStateFromError()
이 메서드와 componentDidCatch 메서드는 에러 상황에서 실행되는 메서드
### getDerivedStateFromError ,componentDidCatch, getSnapShotBeforeUpdate 이 세가지 메서드가 필요한 경우가 있다면 반드시 클랙스형 컴포넌트를 사용해야 함

getDerivedStateFromError는 자식 컴포넌트에서 에러가 발생했을 때 호출되는 에러 메시지
getDerivedStateFromError는 반드시 state 값을 반환해야 함 그 이뉴는 getDerivedStateFromError의 실행 시점 때문임 getDerivedStateFromError는 하위 컴포넌트에서 에러가 발생했을 경우에 어떻게 자식 리액트 컴포넌트를 렌더링할지 결정하는 용도로 제공되는 메서드이기 때문에 반드시 미리 정의해둔 state값을 반환해야 함 또한 렌더링 과정에서 호출되는 메서드 이기 때무네 부수 효과를 발생시켜서는 안됨 여기서의 부수 효과는 state를 반환하는 것 외의 모든 작업을 의미

componentDidCatch
자식 컴포넌트에서 에러가 발생했을 때 실행됨 getDerivedStateFromError에서 에러를 잡고 state를 결정한 이후에 실행됨. componentDidCatch는 두 개의 인수를 받는데 첫 번째는 getDerivedStateFromError와 동일한 error, 그리고 정확히 어떤 컴포넌트가 에러를 발생시켰는지 정보를 가지고 있는 info
getDerivedStateFromError에서 하지 못했던 부수 효과를 수행할 수 있음
componentDidCatch는 커밋 단계에 실행되기 때문. 즉 리액트에서 에러 발생 시 이 메서드에서 제공되는 에러 정보를 바탕으로 로깅하는 등의 용도로 사용할 수 있음

### ErrorBoundary는 에러 경계 컴포넌트를 만들기 위한 목적으로 많이 사용됨 
모든 에러를 잡아낼 수 있는 것은 아님. ErrorBoundary는 애플리케이션 루트에서 사용되지만 ErrorBoundary는의 경계 외부에 있는 에러는 잡을 수 없음.
이 외부에서 발생한 에러는 또 다른 ErrorBoundary를 찾아갈 것이며 만약 이를 찾지 못하면 일반적인 자바스크립트 코드처럼 에러는 thorw 됨
이를 반대로 얘기하면 ErrorBoundary를 여러 개 선언해서 컴포넌트별로 에러 처리를 다르게 적용할 수 있음 에러가 발생한 컴포넌트 트리 영역만 별도로 처리해서 애플리케이션 전체에 에러가 전파되어 표시되는 것을 방지할 수 있음

### 클래스형 컴포넌트의 한계
데이터의 흐름을 추적하기 어렵다
애플리케이션 내부 로직의 재사용이 어렵다
기능이 많아질수록 컴포넌트의 크기가 커진다
클래스 함수에 비해 상대적으로 어렵다
코드 크기를 최적화하기 어렵다
핫 리로딩을 하는 데 상대적으로 불리하다

## 2.3.2 함수형 컴포넌트
render 내부에서 필요한 함수를 선언할 때 this 바인딩을 조심할 필요도 없으며 state는 객체가 아닌 각각의 원시값으로 관리되어 훨씬 사용하기가 편해짐 물론 state 객체도 관리할 수 있음. 렌더링하는 코드인 return에서도 굳이 this를 사용하지 않더라고 props와 state에 접근할 수 있게 됨

## 2.3.3 함수형 컴포넌트 vs 클래스형 컴포넌트

생명주기 메서드의 부재
함수형 컴포넌트는 props 를 받아 단순히 리액트 요소만 반환하는 함수인 반면, 클래스형 컴포넌트는 render 메서드가 있는 React.Component를 상속받아 구현하는 자바스크립트 클래스이기 때문.
즉 생명주기 메서드는 React.Component에서 오는 것이기 때문에 클래스형 컴포넌트가 아닌 이상 생명주기 메서드를 더는 사용할 수 없다는 뜻
함수형 컴포넌트는 useEffect 훅을 사용해 componentDidMount, componentDidUpdate, componentWillUnmount를 비슷하게 구현 가능. 비슷할 뿐 똑같다는 게 아님. useEffect는 생명주기를 위한 훅이 아님. 컴포넌트의 state를 활용해 동기적으로 부수 효과를 만드는 메커니즘

함수형 컴포넌트와 렌더링된 값
함수형 컴포넌트는 렌더링 된 값을 고정하고 클래스형 컴포넌트는 그렇지 못한다는 사실

함수형 컴포넌트는 렌더링이 일어날 때마다 그 순간의 값인 props와 state를 기준으로 렌더링 됨 props와 state가 변경된다면 다시 한 번 그 값을 기준으로 함수가 호출된다고 볼 수 있음 반면 클래스형 컴포넌트는 시간의 흐름에 따라 변화하는 this를 기준으로 렌더링이 일어남

## 2.4 렌더링은 어떻게 일어나는가?
브라우저에서의 렌더링이란 쉽게 말해 HTML과 CSS 리소스를 기반으로 웹페이지에 필요한 UI를 그리는 과정을 의미
리액트에도 렌더링이라는 과정이 존재. 리액트의 렌더링은 브라우저가 렌더링에 필요한 DOM 트리를 만드는 과정을 의미

## 2.4.1 리액트의 렌더링이란?
리액트에서의 렌더링이란 리액트 애플리케이션 트리 안에 있는 모든 컴포넌트들이 현재 자신들이 가지고 있는 props 와 state의 값을 기반으로 어떻게 UI를 구성하고 이를 바탕으로 어떤 DOM 결과를 브라우저에 제공할 것인지 계싼하는 일련의 과정. 만약 컴포넌트가 props와 state와 같은 상태값을 가지고 있지 않다면 오직 해당 컴포넌트가 반환하는 JSX 값에 기반해 렌더링이 일어나게 됨

## 2.4.2 리액트의 렌더링이 일어나는 이유

리액트에서 배열에 key를 쓰지 않으면 콘솔에 경고가 출력되기 때문에 key를 유일한 값으로 추가하는 것이지 일반적이지만 정작 왜 추가해야 하는지는 모르는 경우가 많음
왜 key가 필요할까? 리렌더링이 발생하는 동안 형제 요소들 사이에서 동일한 요소를 식별하는 값
동일한 자식 컴포넌트가 여러 개 있는 구조의 경우 리렌더링이 발생하면 current 트리와 workInProgress 트리 사이에 어떠한 컴포넌트가 변경이 되었는지 구별해야 하는데 이 두 트리 사이에서 같은 컴포넌트인지를 구별하는 값이 바로 key

child는 memo로 선언돼 있으면 리렌더링 발생하지 않음
key의 변화는 리렌더링을 야기함. 이러한 특징 이용하면 key를 활용해 강제로 리레더링을 일으키는 것이 가능해짐

## 2.4.3 리액트의 렌더링 프로세스
렌더링 컴포넌트의 루트에서부터 아래쪽으로 내려가면서 업데이트가 필요하다고 지정돼 있는 모든 컴포넌트를 찾음. 컴포넌트를 발견하면 클래스형 컴포넌트의 경우에는 클래스 내부의 render()함수를 실행하게 되고, 함수형 컴포넌트의 경우에는 FunctionComponent() 그 자체를 호출한 뒤 그 결과물을 저장
렌더링 결과물은 JSX 문법으로 구성돼 있고 자바스크립트로 컴파일되면서 React.createElement()를 호출하는 구문으로 변환됨
createElement는 브라우저의 UI 구조를 설명할 수 있는 일반적인 자바스크립트 객체를 반환
렌더링 프로세스가 실행되면서 이런 과정을 거쳐 각 컴포넌트의 렌더링 결과물을 수집, 리액트의 새로운 트리인 가상 DOM과 비교해 실제 DOM에 반영하기 위한 모든 변경 사항을 수집
계산하는 과정은 재조정, 재조정 끝나면 모든 변경 사항을 하나의 동기 시쿼느로 DOM에 적용해 변경된 결과물이 보이게 됨

## 2.4.4 렌더와 커밋
렌더 단계는 컴포넌트를 렌더링하고 변경 사항을 계산하는 모든 작업. 즉 렌더링 프로세스에 컴포넌트를 실행해 (render() 또는 return)이 이 결과와 이전 가상 DOM을 비교하는 과정을 거쳐 변경이 필요한 컴포넌트를 체크하는 단계
크게 type, props, kye 비교, 이 세 가지 중 하나라도 변경된 것이 있으면 변경이 필요한 컴포넌트로 체크
커밋 단계는 렌더 단계의 변경 사항을 실제 DOM에 적용해 사용자에게 보여주는 과정
비로소 브라우저의 렌더링이 발생
리액트가 먼저 DOM을 커밋 단계에서 업데이트 한다면 이렇게 만들어진 모든 DOM 노드 및 인스턴스를 가리키도록 리액트 내부의 참조를 업데이트함.
그 다음 생명주기 개념이 있는 클래스형 컴포넌트에서는 componentDidMount, componentDidUpdate 메서드를 호출하고 함수형 컴포넌트에서는 useLayoutEffect 훅을 호출

리액트 렌더링 일어난다고 해서 무조건 DOM 업데이트가 일어나는 것은 아님. 변경 사항을 계산했는데 아무런 변경 사항이 감지되지 않는다면 이 커밋 단계는 생략될 수 있음
리액트는 꼭 가시적인 변경이 일어나지 않아도 발생할 수 있음

## 2.4.5 일반적인 렌더링 시나리오 살펴보기
컴포넌트를 렌더링 하는 작업은 별도로 렌더링을 피하기 위한 조치가 돼 있지 않는 한 모든 컴포넌트에 영향을 미침. 부모가 변경됐다면 props가 변경됐는지와 상관없이 무조건 자식 컴포넌트도 리렌더링됨
상위 컴포넌트 특히 루트에서 무언가 렌더링을 발생시키는 작업이 일어난다는 것은 하위 모든 컴포넌트의 리렌더링을 트리거한다는 뜻

컴포넌트에 memo를 추가하면 props가 변경되지 않으면 렌더링이 생략되므로 커밋 단계도 생략됨 

## 2.5 컴포넌트와 함수의 무거운 연산을 기억해 두는 메모이제이션
리액트에서 제공하는 API 중 useMemo, useCallback 훅과 고차 컴포넌트인 memo는 리액트에서 발생하는 렌더링을 최소한으로 줄이기 위해 제공됨

| 도구         | 대상         | 주 목적         | 주 사용 시기                         |
|--------------|--------------|------------------|--------------------------------------|
| React.memo   | 컴포넌트     | 리렌더링 방지    | 자식 컴포넌트의 props가 자주 안 바뀔 때 |
| useMemo      | 값(계산 결과) | 계산 캐싱        | 무거운 연산이 있을 때                |
| useCallback  | 함수         | 함수 참조 유지    | 자식에 콜백 함수 전달할 때           |

 
