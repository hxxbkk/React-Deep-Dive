# 03장
함수형 컴포넌트가 상태를 사용하거나 클래스형 컴포넌트의 생명주기 메소드를 대체하는 등의 다양한 작업을 하기 위해 훅이라는 것이 추가됨

## 3.1.1 useState
함수형 컴포넌트 내부에서 상태를 정의하고 이 상태를 관리할 수 있게 해주는 훅
```
import { useState } from 'react'
const [state, setState] = useState(initialState)
```

useState 훅의 반환 값은 배열이며 배열의 첫 번째 원소로 state 값 자체를 사용할 수 있고 두 번째 원소인 setState 함수를 사용해 해당 state의 값을 변경할 수 있음
useState는 자바스크립트의 특징 중 하나인 클로저에 의존해 구현돼 있을 것이라는 사실을 짐작해 볼 수 있음

### 게으른 초기화
useState에 변수 대신 함수를 넣는 것을 게으른 초기화라고 함
리액트 공식 문서에서는 게으른 초기화는 useState 초깃값이 복잡하거나 무거운 연산을 포함하고 있을 때 사용하라고 되어있음 이 게으른 초기화는 오로지 state가 만들어질 때만 사용됨

### 언제 쓰면 좋을까?
localstorage나 sessionStorage에 대한 접근 map, filter,find 같은 배열에 대한 접근 혹은 초깃값 계산을 위해 함수 호출이 필요할 때와 같이 무거운 연산을 포함해 실행 비용이 많이 드는 경우

## 3.1.2 useEffect
애플리케이션 내 컴포넌트의 여러 값들을 활용해 동기적으로 부수 효과를 만드는 메커니즘
이 부수 효과가 어떤 상태값과 함께 실행되는지 살펴보는 것이 중요

### useEffect란?
첫 번째 인수로는 실행할 부수 효과가 포함된 함수를 두 번째 인수로는 의존성 배열을 전달함
의존성 배열이 변경될 때마다 useEffect의 첫 번째 인수인 콜백을 실행한다는 것

### 어떻게 의존성 배열이 변경된 것을 알고 실행될까?
함수형 컴포넌트는 매번 함수를 실핼해 렌더링을 수행함, 함수형 컴포넌트는 state와 props 값을 갖고 있음
useEffect는 state와 props의 변화 속에서 일어나는 렌더링 과정에서 실행되는 부수 효과 함수라고 볼 수 있음

### 클린업 함수의 목적
일반적으로 클린업 함수는 이벤트를 등록하고 지울 때 사용해야 한다고 알려져 있음
함수형 컴포넌트의 useEffect는 그 콜백이 실행될 때마다 이전의 클린업 함수가 존재한다면 그 클린업 함수를 실행한 뒤에 콜백을 실행함
따라서 이벤트를 추가하기 전에 이전에 등록했던 이벤트 핸들러를 삭제하는 코드를 클린업 함수에 추가하는 것, 이렇게 함으로써 특정 이벤트의 핸들러가 무한히 추가되는 것을 방지
클린업 함수는 언마운트 라기보다는 함수형 컴포넌트가 리렌더링 됐을 때 의존성 변화가 있었을 당시 이전의 값을 기준으로 실행되는, 이전 상태를 청소해주는 개념으로 보는 것이 옳음

### 의존성 배열
보통 빈 배열을 두거나 아예 아무런 값도 넘기지 않거나 사용자가 직접 원하는 값을 넣어줄 수 있음
빈 배열이면 최초 렌더링 직후에 실행된 다음부터 더 이상 실행되지 않음 아무 값도 넣어주지 않는다면 렌더링 발생될 때마다 실행 이는 보통 컴포넌트가 렌더링 됐는지 확인하기 위해 사용

### useEffect 사용할 때 주의할 점
eslint-disable-ine react-hooks/exhaustive-deps 주석은 최대한 자제하라
useEffct의 첫 번째 인수에 함수명을 부여하라
거대한 useEffect릉 만들지 마라
불필요한 외부 함수를 만들지 마라

## 3.1.3 useMemo
비용이 큰 연산에 대한 결과를 저장(메모이제이셩)해 두고 이 저장된 값을 반환하는 훅
리액트에서 최적화를 떠올릴 때 가장 먼저 언급되는 훅
첫 번째 인수로는 어떠한 값을 반환하는 생성 함수를 두 번째 인수로는 해당 함수가 의존하는 값의 배열을 전달
메모이제이션은 단순히 값뿐만 아니라 컴포넌트도 가능

## 3.1.4 useCallback
useMemo가 값을 기억했다면 useCallback은 인수로 넘겨받은 콜백 자체를 기억함
특정 함수를 새로 만들지 않고 다시 재사용한다는 의미
함수의 재생성을 막아 불필요한 리소스 또는 리렌더링 방지하고 싶을 때 사용해볼 수 있음
useCallback은 useMemo를 사용해서 구현할 수 있음useMemo와 useCallback의 유일한 차이는 메모이제이션 하는 대상이 변수냐 함수냐일 뿐
useCallback 이나 useMemo는 모두 동일한 역할을 함

## 3.1.5 useRef
useState와 동일하게 컴포넌트 내부에서 렌더링이 일어나도 변경 가능한 상태값을 저장한다는 공통점 있음 그러나 구별되는 큰 차이점 두 가지를 가지고 있음
useRef는 반환값인 객체 내부에 있는 current로 값에 접근 또는 변경할 수 있음
useRef는 그 값이 변하더라도 렌더링을 발생시키지 않음
컴포넌트가 렌더링될 때만 생성되며 컴포넌트 인스턴스가 여러 개더라도 각각 별개의 값을 바라봄
개발자가 원하는 시점의 렌더링 값을 렌더링에 영향을 미치지 않고 보관해 두고 싶다면 useRef를 사용하는 것이 좋음

## 3.1.6 useContext

### Context란?
prop 내려주기를 극복하기 위해 등장한 개념이 바로 콘텍스트
콘텍스트를 사용하면 명시적인 props 전달 없이도 선언한 하위 컴포넌트 모두에게 자유롭게 원하는 값을 사용할 수 있음

### Context를 함수헝 컴포넌트에서 사용할 수 있게 해주는 useContext훅
useContext는 상위 컴포넌트에서 만들어진 Context를 함수형 컴포넌트에서 사용할 수 있도록 만들어진 훅
여러 개의 Provider가 있다면 가장 가까운 Provider의 값을 가져오게 됨
useContext를 사용할 때 주의할 점useContext를 함수형 컴포넌트 내부에서 사용할 때는 항상 컴포넌트 재활용이 어려워진다는 점을 염두애 둬야함
콘텍스트는 상태를 주입해 주는 API
useContext로 상태 주입을 최적화했다면 반드시 Provider의 값이 변경될 때 어느 식으로 렌더링되는지 눈여겨 봐야 함.
useContext로는 주입된 상태를 사용할 수 있을 뿐 그 자체로는 렌더링 최적화에 아무런 도움 안됨

## 3.1.7 useReducer
useState의 심화버전으로 볼 수 있음

반환값은 usestate와 동일하게 길이가 2인 배열
state: 현재 useReducer가 가지고 있는 값을 의미. usestate와 마찬가지로 배열을 반환하는데 동일하게 첫 번 째 요소가 이 값
dispatcher: state를 업데이트하는 함수useReducer가 반환하는 배열의 두 번째 요소다 setState는 단순히 값을 넘겨주지만 여기서는 action을 넘겨준다는 점이 다름. 이 action은 state를 변경할 수 있는 액션을 의미

usestate의 인수와 달리 2개에서 3개의 인수를 필요로 함
reducer: useReducer의 기본 action을 정의하는 함수. 이 reducer는 useReducer의 첫 번째 인수로 넘겨주어야 함
initialstate: 두 번째 인수로 useReducer의 초깃값을 의미
init: usestate의 인수로 함수를 넘겨줄 때처럼 초깃값을 지연해서 생성시키고 싶을 때 사용하는 함수. 이 함수는 필수값이 아니며 만약 여기에 인수로 넘겨주는 함수가 존재한다면 useState와 동일하게 게으른 초기화가 일어나며 initialstate를 인수로 init 함수가 실행됨

state 값을 변경하는 시나리오를 제한적으로 두고 이에 대한 변경을 빠르게 확인할 수 있게끔 하는 것이 Reducer의 목적
useReducer나 useState 둘 다 세부 작동과 쓰임에만 차이가 있을뿐 결국 클로저를 활용해 값을 가둬서 state를 관리한다는 사실에는 변화 없음

## 3.1.8 useImperativeHandle

### forwardRef 살펴보기
forwardRef간 탄생한 배경은 ref를 전달하는 데 있어서 일관성을 제공하기 위함
forwardRef를 사용하면 ref를 props로 전달할 수 있고 전달받은 컴포넌트에서도 ref라는 이름을 그대로 사용할 수 있음

### useImperativerHandle이란?
부모에게서 넘겨받은 ref를 원하는 대로 수정할 수 있는 훅
useImperativeHandle을 사용하면 부모 컴포넌트에서 노출되는 값을 원하는 대로 바꿀 수 있음
원래 ref는 {current: <HTMLElement>}와 같은 형태로 HTMLElement만 주입할 수 있는 객체였음 그러나 여기서는 전달받은 ref에다 useImperativeHandle 훅을 사용해 추가적인 동작을 정의함 부모는 단순히 HTMLElement뿐만 아니라 자식 컴포넌트에서 새롭게 설정한 객체의 키와 값에 대해서도 접근할 수 있게 됨

## 3.1.9 useLayoutEffect
이 함수의 시그니처는 useEffect와 동이라하나 모든 DOM의 변경 후에 동기적으로 발생
여기서 말하는 DOM 변경이란 렌더링이지 브라우저에 실제로 해당 변경 사항이 반영되는 시점을 의미하는 것은 아님

1. 리액트가 DOM을 업데이트
2. useLayoutEffect를 실행
3. 브라우저에 변경 사항을 반영
4. useEffect를 실행

항상 useLayoutEffect가 useEffect 보다는 먼저 실행됨. useLayoutEffect가 브라우저에 변경 사항이 반영 되기 전에 실행되는 반면 useEffect는 브라우저에 변경 사항이 반영된 이후에 실행되기 때문.
동기적으로 발생한다는 것은 useLayoutEffect의 실행이 종료될 때까지 기다린 다음에 화면을 그리다는 것을 의미, 즉 리액트 컴포넌트는 useLayoutEffect가 완료될 때까지 기다리기 때문에 컴포넌트가 잠시 동안 일시 중지되는 것과 같은 일이 발생하게 됨
이러한 작동 방식으로 인해 웹 애플리케이션 성능에 문제가 발생할 수 있음

### 그럼 언제 useLayoutEffect를 사용하는 것이 좋을까? 
DOM은 계산됐지만 이것이 화면에 반영되기 전에 하고 싶은 작업이 있을 때와 같이 반드시 필요할 때만 사용하는 것이 좋음

## 3.1.10 useDebugValue
일반적으로 프로덕션 웹서비스에서 사용하는 훅이 아님 이 훅은 리액트 애플리케이션을 개바하는 과정에서 사용되는데 디버깅하고 싶은 정보를 이 훅에다 사용하면 리액트 개발자 도구에서 볼 수 있음
useDebugValue는 사용자 정의 훅 내부의 내용에 대한 정보를 남길 수 있는 훅, 오직 다른 훅 내부에서만 실행할 수 있음에 주의
컴포넌트 레벨에서 실행한다면 작동하지 않음

## 3.1.11 훅의 규칙
1. 최상위에서만 훅을 호출해야 함. 반복문이나 조건문, 중첩된 함수 내에서 훅을 실행할 수 없음 이 규칙을 따라야만 컴포넌트가 렌더링될 때마다 항상 동일한 순서로 훅이 호출되는 것을 보장할 수 있음
2. 훅을 호출할 수 있는 것은 리액트 함수형 컴포넌트, 혹은 사용자 정의 훅의 두 가지 경우뿐. 일반 자바스크립트 함수에서는 훅을 사용할 수 없음

## 3.2 사용자 정의 훅과 고차 컴포넌트 중 무엇을 써야 할까?
리액트에서는 재사용할 수 있는 로직을 관리할 수 있는 두 가지 방법이 있음
사용자 정의 훅과 고차 컴포넌트임

## 3.2.1 사용자 정의 훅
서로 다른 컴포넌트 내부에서 같은 로직을 공유하고자 할 때 주로 사용하는 것이 바로 사용자 정의 훅
고차 컴포넌트는 굳이 리액트가 아니더라도 사용할 수 있는 기법이지만 사용자 정의 훅은 리액트에서만 사용할 수 있는 방식
사용자 정의 훅의 규칙 중 하나는 이름이 반드시 use로 시작하는 함수를 만들어야 한다는 것

## 3.2.2 고차 컴포넌트
컴포넌트 자체의 로직을 재사용하기 위한 방법
고차 컴포넌트는 고차 함수의 일종으로 자바스크립트의 일급 객체 함수의 특징을 이용하므로 굳이 리액트가 아니더라도 자바스크립트 환경에서 널리 쓰일 수 있음
리액트에서 가장 유명한 고차 컴포넌트는 리액트에서 제공하는 API 중 하나인 React.memo

### React.memo란?
props의 변화가 없음에도 컴포넌트의 렌더링을 방지하기 위해 만들어진 리액트의 고차 컴포넌트가 바로 React.memo
React.memo는 렌더링하기에 앞서 props를 비교해 이전과 props가 같다면 렌더링 자체를 생략하고 이전에 기억해 둔 컴포넌트를 반환함
이 방식은 클래스형 컴포넌트에서 소개했던 PureComponent와 매우 유사

### 고차 함수 만들어보기
리액트의 함수형 컴포넌트도 결국 함수이기 때문에 함수를 기반으로 고차 함수를 만드는 것을 먼저 이해해야 함
고차 함수의 사전적인 정의를 살표벼모녀 '함수를 인수로 받거나 결과로 반환하는 함수'라고 정의돼 있음
가장 대표적인 고차 함수로는 리액트에서 배열을 렌더링할 때 자주 사용하는 Array.prototype.map을 들 수 있음

### 고차 함수를 활용한 리액트 고차 컴포넌트 만들어보기
주의할 점은 고차 컴포넌트는 with로 시작하는 이름을 사용해야 함
강제되는 사항은 아니지만 리액트 라우터의 withRouter와 같이 리액트 커뮤니티에 널리 퍼진 일종의 관습
부수 효과를 최소화해야 함. 고차 컴포넌트는 반드시 컴포넌트를인수로 받게 되는데 반드시 컴포넌트의 props를 임의로 수정, 추가, 삭제하는 일은 없어야 함

## 3.2.3 사용자 정의 훅과 고차 컴포넌트 중 무엇을 써야할까?
### 사용자 정의 훅이 필요한 경우
단순히 useEffect, useState와 같이 리액트에서 제공하는 훅으로만 공통 로직을 격리할 수 있다면 사용자 정의 훅을 사용하는 것이 좋음
단순히 컴포넌트 전반에 걸쳐 동일한 로직으로 값을 제공하거나 특정한 훅의 작동을 취하게 하고 싶다면 사용자 정의 훅을 사용하는 것이 좋음

### 고차 컴포넌트를 사용해야 하는 경우
함수형 컴포넌트의 반환값 즉, 렌더링의 결과물에도 영향을 미치는 공통 로직이라면 고차 컴포넌트를 사용. 고차 컴포넌트는 공통화된 렌더링 로직을 처리하기에 매우 훌륭한 방법 그러나 고차 컴포넌트가 많아질수록 복잡성이 기하급수적으로 증가하므로 신중하게 사용해야 함

