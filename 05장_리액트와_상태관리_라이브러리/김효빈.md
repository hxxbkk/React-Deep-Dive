# 05장
리액트와 상태관리 라이브러리

### 5.1 상태관리는 왜 필요한가?
흔히 웹 애플리케이션을 개발할 때 이야기하는 상태는 어떠한 의미를 지닌 값이며 애플리케이션의 시나리오에 따라 지속적으로 변경될 수 있는 값을 의미

상태로 분류될 수 있는 것들
- UI
- URL
- 폼
- 서버에서 가져온 값(ex. API 요청)

### 5.1.1 리액트 상태 관리의 역사

Flux 패턴의 등장
이 당시 웹 개발 상황은 웹 애플리케이션이 비대해지고 상태(데이터)도 많아짐에 따라 어디서 어떤 일이 일어나서 이 상태가 변했는지 등을 추적하고 이해하기가 매운 어려운 상황이었음

양방향이 아닌 단방향으로 데이터 흐름을 변경하는 것이 바로 Flux 패턴의 시작
- 액션 : 어떠한 작업을 처리할 액션과 그 액션 발생 시 함께 포함시킬 데이터를 의미, 액션 타입과 데이터를 각 각 정의해 이를 디스패처로 보냄
- 디스패치 : 액션을 스토어에 보내는 역할을 함. 콜백 함수 형태로 앞서 액션이 정의한 타입과 데이터를 모두 스토어에 보냄
- 스토어 : 여기에서 실제 상태에 따른 값과 상태를 변경할 수 있는 메서드를 가지고 있음. 액션의 타입에 따라 어떻게 이를 변경할지가 정의돼 있음
- 뷰 : 리액트의 컴포넌트에 해당하는 부분으로 스토어에서 만들어진 데이터를 가져와 렌더링하는 역할을 함. 또한 뷰에서도 사용자의 입력이나 행위에 따라 상태를 업데이트하고자 할 수 있음. 이 경우엔 뷰에서 액션을 호출하는 구조로 구성

상태와 그 상태의 변경에 대한 흐름과 방식을 단방햑으로 채택한 것이 바로 리액트 기반 Flux의 특징

시장 지배자 리덕스의 등장
리덕스 또한 최초에는 이 Flux 구조를 구현하기 위해 만들어진 라이브러리 중 하나였음 여기에 Elm 아키텍처를 도입함

Elm은 웹페이지를 선언적으로 작성하기 위한 언어
모델, 뷰, 업데이트가 Elm 아키텍처의 핵심
Elm은 Flux와 마찬가지로 데이터 흐름을 세 가지로 분류하고 이를 단방향으로 강제해 웹 애플리케이션의 상태를 안정적으로 관리하고자 노력함 그리고 이 리덕스는 Elm 아키텍처의 영향을 받아 작성됨

리덕스는 하나의 상태 객체를 스토어에 저장해 두고 이 객츠를 업데이트하는 작업을 디스패치해 업데이를 수행함 이러한 작업은 reduce 함수로 발생시킬 수 있음 이 함수의 실행은 웹 애플리케이션 상태에 대한 완전히 새로운 복사본을 반환하 다음, 애플리케이션에 이 새롭게 만들어진 상태를 전파하게 됨
리덕스의 등장으로 prop 내려주기 문제를 해결할 수 있었고 스토어가 필요한 컴포넌트라면 단지 connect만 쓰면 스토어에 바로 접근 가능 그렇지만 마냥 편한 것은 아님.
단순히 하나의 상태를 바꾸고 싶어도 해야 할 일이 너무 많음 그렇지만 지금은 작업이 많이 간소화 됨

Context API와 useContext
props로 상태를 넘겨주지 않더라도 Context API를 사용하면 원하는 곳에서 Context Provider가 주입하는 상태를 사용할 수 있게 된 것

Context API는 상태 관리가 아닌 주입을 도와주는 기능이며 렌더링을 막아주는 기능 또한 존재하지 않으니 사용할 때 주의 필요

훅의 탄생, 그리고 React Query와 SWR
React Query와 SWR은 모두 외부에서 데이터를 불러오는 fetch를 관리하는 데 특화된 라이브러리지만 API 호출에 대한 상태를 관리하고 있기 때문에 HTTP 요청에 특화된 상태 관리 라이브러리라 볼 수 있음

Recoil, Zustand, Jotai, Valtio에 이르기까지
이러한 상태 관리 라이브러리는 기존의 리덕스와의 차이점이 있는데 바로 훅을 활용해 작은 크기의 상태를 효율적으로 관리한다는 것

### 5.2 리액트 훅으로 시작하는 상태 관리

### 5.2.1 가장 기본적인 방법 : useState와 useReducer
useState와 useReducer 모두 약간의 구현상의 차이만 있을 뿐, 두 훅 모두 지역 상태 관리를 위해 만들어졌다는 것을 알 수 있음
이 두 훅은 만들기에 따라 재사용할 수 있는 지역 상태를 만들어 주지만 지역 상태라는 한계 때문에 여러 컴포넌트에 걸쳐 공유하기 위해서는 컴포넌트 트리를 재설계하는 등의 수고로움이 필요

### 5.2.2 지역 상태의 한계를 벗어나보자: useState의 상태를 바깥으로 분리하기
useStoreSelector나 useStore를 사용했던 것과 마찬가지로 useSubscription을 사용하면 외부에 있는 데이터를 가져와서 사용하고 리렌더링까지 정상적으로 수행되는 것 확인할 수 있음

### 5.2.3 useState와 Context를 동시에 사용해보기
리액트 생태계에는 많은 상태 관리 라이브러리가 있찌만 이것들이 작동하는 방식은 결국 다음과 같음
useState, useReducer가 가지고 있는 한계, 컴포넌트 내부에서만 사용할 수 있는 지역 상태라는 점을 극복하기 위해 외부 어딘가에 상태를 둠. 이는 컴포넌트 최상단 내지는 상태가 필요한 부모가 될 수도 있고, 혹은 격리된 자바스크립트 스코프 어딘가일 수도 있음
이 외부의 상태 변경을 각자의 방식으로 감지해 컴포넌트의 렌더링을 일으킴

### 5.2.4 상태 관리 라이브러리 Recoil, Jotai, Zustand 살펴보기
Recoil과 Jotai는 Context와 Provider 그리고 훅을 기반으로 가능한 작은 상태를 효율적으로 관리하는 데 초점을 맞추고 있음
Zustand는 리덕스와 비슷하게 하나의 큰 스토어를 기반으로 상태를 관리하느 ㄴ라이브러리, 이 하나의 큰 스토어는 Context가 아니라 스토어가 가지는 클로저를 기반으로 생성되며 이 스토어의 상태가 변경되면 이 상태를 구독하고 있는 컴포넌트에 전파해 리렌더링을 알리는 방식

페이스북이 만든 상태 관리 라이브러리 Recoil
리액트에서 훅의 개념으로 상태 관리를 시작한 최초의 라이브러리 중 하나이며 최소 상태 개념인 Atom을 처음 리액트 생태계에서 선보이기도 함

atom
atom은 상태를 나타내는 Recoil의 최소 상태 단위
atom은 key 값을 필수로 가지며 이 키는 다른 atom과 구별하는 식별자가 되는 필수 값, 이 키는 애플리케이션 내부에서 유일한 값이어야 하기 때문에 atom과 selector를 만들 때 반드시 주의를 기울여야 함. default는 atom의 초기값 의미

Reocil 종합
먼저 애플리케이션의 최상단에 <RecoilRoot />선언해 하나의 스토어를 만들고 atom이라는 상태 단위를 <RecoilRoot />에서 만든 스토어에 등록함
atom은 Recoil에서 관리하는 작은 상태 단위이며 각 값은 고유한 값이 key를 바탕으로 구별됨. 컴포넌트는 Recoil에서 제공하는 훅을 통해 atom의 상태 변화를 구독하고 값이 변경되면 forceUpdate 같은 기법을 통해 리렌더링을 실행해 최신 atom을 가져오게 됨

Recoil에서 영감을 받은, 그러나 조금 더 유연한 Jotai
Jotai는 상향식 접근법을 취하고 있다고 나와 있는데 이는 리덕스와 같이 하나의 큰 상태를 애플리케이션에서 내려주는 방식이 아니라 작은 단위의 상태를 위로 전파할 수 있는 구조를 취하고 있음을 의미, 또한 Context의 문제점인 불필요한 리렌더링이 일어난다는 문제를 해결하고자 설계돼 있으며 추가적으로 개발자들이 메모이제이션이나 최적화를 거치지 않아도 리렌더링이 발생되지 않도록 설계돼 있음

atom
Recoil에서 영감을 받았다고 언급한 것처럼 Jotai에도 atom 개념 존재
atom은 Recoil과 마찬가지로 최소 단위의 상태를 의미.
Recoil과 다르게 atom 하나만으로도 상태를 만들 수도, 또 이에 파생된 상태를 만들 수도 있음. atom이 최소한의 상태 단위라는 것까지는 동일하지만 atom 하나로 파생된 상태까지 만들 수 있다는 점에서 차이가 있음

특징
Recoil의 atom 개념을 도입하면서도 API가 간결한다는 점
Recoil의 atom에서는 각 상태값이 모두 별도의 키를 필요로 하기 때문에 이 키를 별도로 관리해야 하는데 Jotai는 이러한 부분을 추상화해 사용자가 키를 관리할 필요 없음. Jotai가 별도의 문자열 키가 없어도 각 값들을 관리할 수 있는 것은 객체의 참조를 통해 값을 관리하기 때문. 객체의 참조를 WeakMap에 보관해 해당 객체 자체가 변경되지 않는 한 별도의 키가 없이도 객체의 참조를 통해 값을 관리할 수 있음
Recoil에서는 atom에서 파생된 값을 만들기 위해서는 selector가 필요했지만 Jotail에서는 selector가 없이도 atom만으로 atom 값에서 또 다른 파생된 상태 만들 수 있음

작고 빠르며 확장에도 유연한 Zustand
Zustand는 리덕스에 영감을 받아 만들어짐
atom이라는 개념으로 최소 단위의 상태를 관리하는 것이 아니라 zustand에서는 하나의 스토어를 중앙 집중형으로 활용해 이 스토어 내부에서 상태를 관리

특징
특별히 많은 코드를 작성하지 않아도 빠르게 스토어를 만들고 사용할 수 있다는 큰 장점이 있음. 스토어를 만들고 이 스토어에 파생된 값을 만드는 데 단 몇 줄의 코드면 충분함. 간단하고 빠르게 상태를 정의할 수 있어 상태를 관리하는 입장에서 한결 가볍고 편리
이 가볍게 쓸 수 있다는 장점을 만들어 주는 것은 Zustand 자체의 라이브러리 크기도 한몫함. 즉, API가 복잡하지 않고 사용이 간단해 쉽게 접근할 수 있는 상태 관리 라이브러리로 Zustand를 손꼽을 수 있음
그리고 Jotai와 마찬가지로 타입스크립 기반으로 작성돼 있기 때문에 별도로 @types를 설치하거나 임의로 작성된 d.ts에 대한 우려 없이 타입스크립트를 자연스럽게 쓸 수 있음.미들웨어를 지원
