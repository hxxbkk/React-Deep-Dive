# 01 - 07 요약

---
## 1.1 자바스크립트의 동등 비교

리액트 컴포넌트 랜더링이 일어나는 이유 중 하나가 바로 `props`의 동등 비교에 따른 결과입니다. 이 `props`의 동등 비교는 객체의 얕은 비교를 기반으로 이루어집니다.

## 1.1.1 자바스크립트의 데이터 타입

자바스크립트의 모든 값은 데이터 타입을 가지고 있습니다. 크게 원시 타입과 객체 타입으로 나눌 수 있습니다.

- **원시 타입**: `boolean`, `null`, `undefined`, `number`, `string`, `symbol`, `bigint`
- **객체 타입**: `object`

### 원시 타입

원시 타입은 객체가 아닌 다른 모든 타입을 말합니다. 객체가 아니므로 메서드를 가지지 않습니다.

- `undefined`: 선언되었지만 할당되지 않은 값
- `null`: 명시적으로 비어있음을 나타내는 값
- `boolean`: `falsy`와 `truthy`라는 false와 true와 같은 것이 있습니다. 객체와 배열은 내부에 값이 존재하는지 여부에 관계없이 `truthy`로 취급됩니다.
- `number`: 2진수, 8진수, 16진수 등의 별도 데이터 타입을 제공하지 않으며, 각 진수별로 값 표현하면 모두 10진수로 해석되어 동일한 값으로 표시됩니다.
- `BigInt`: `number`가 다룰 수 있는 크기의 제한을 극복하기 위해 나온 것입니다.
- `string`: 백틱(``` ` ```)을 사용해서 표현한 문자열은 템플릿 리터럴이라고 합니다. 자바스크립트 문자열은 원시 타입이며 변경이 불가능합니다.
- `symbol`: 중복되지 않는 고유한 값을 나타내기 위해 만들어졌습니다.

### 객체 타입

객체 타입은 참조를 전달한다고 해서 "참조 타입"으로도 불립니다.

## 1.1.2 값 저장 방식의 차이

원시 타입은 불변 형태의 값으로 저장됩니다. 이 값은 변수 할당 시점에 메모리 영역을 차지하고 저장됩니다. 반면, 객체는 프로퍼티를 삭제, 추가, 수정할 수 있으므로 원시 값과 다르게 변경 가능한 형태로 저장됩니다. 값을 복사한 뒤 값이 아닌 참조를 전달합니다.

## 1.1.3 자바스크립트의 또 다른 공식 비교: `object.is`

`object.is`는 두 개의 인수를 비교합니다. `===`와 동일하게 타입이 다르면 `false`를 반환합니다. 객체 비교에는 별 차이가 없습니다.

## 1.1.4 리액트에서의 동등 비교

리액트에서의 동등 비교는 `object.is` 기반의 `shallowEqual` 함수로 이루어집니다.

---

## 1.2 함수

## 1.2.1 함수란 무엇인가?
자바스크립트에서 함수란 작업을 수행하거나 값을 계산하는 등의 과정을 표현하고, 이를 하나의 블록으로 감싸서 실행 단위로 만들어 놓은 것을 의미


function Component(props) { 
	return <div>{props.hello}</div>
}
Component라고 하는 함수를 선언하고 매개변수로는 일반적으로 props라고 부르는 단일 객체를 받으며 return 문으로 JSX를 반환한다.

## 1.2.2 함수를 정의하는 4가지 방법

### 함수 선언문 
가장 일반적으로 사용하는 방식

```
function add(a, b) {
	return a + b;
}
```

함수 선언문은 표현식이 아닌 일반 문으로 분류된다. 표현식이란 무언가 값을 산출하는 구분을 의미, 앞선 함수 선언은 어떠한 값도 표현되지 않았으므로 표현식이 아니라 문으로 분류된다.

### 함수 표현식
프로그래밍 세계에서 일급 ㄱ객체란 다른 객체들에 일반적으로 적용 가능한 연산을 모두 지원하는 객체를 의미, 함수는 다른 함수의 매개변수가 될 수도 있고, 반환값이 될 수도 있으며 할당도 가능하므로 일급 객체가 되기 위한 조건을 모두 갖추고 있다.

### 함수 표현식과 선언 식의 차이
이 두가지 방식의 큰 차이는 호이스팅 여부다
호이스팅은 함수 선언문이 마치 코드 맨 앞단에 작성된 것처럼 작동하는 자바스크립트의 특징을 의미

함수의 호이스팅은 함수에 대한 선언을 미리 메모리에 등록하는 작업을 의미한다. 코드의 순서에 상관없이 정상적으로 함수를 호출할 수 있게 된다.
함수 표현식은 함수를 변수에 할당했다. 변수도 마찬가지로 호이스팅이 발생한다. 그러나 함수의 호이스팅과는 다르게 호이스팅 되는 시점에서 var의 경우에는 undefined로 초기화한다는 차이가 있다. 함수와 다르게 변수는 런타임 이전에 undefined로 초기화되고 할당문이 실행되는 시점, 즉 런타임 시점에 함수가 할당되어 작동한다.

### Function 생성자

### 화살표 함수
function이라는 키워드 대신 => 라는 화살표를 활용해서 함수를 만든다. 
```
const add = (a, b) => {
	return a + b;
}

const add = (a, b) => a + b;
```

화살표 함수는 constructor를 사용할 수 없다. arguments가 존재하지 않는다.

화살표 함수와 일반 함수의 가장 큰 차이점은 바로 this 바인딩이다.
먼저 this는 자신이 속한 객체나 자신이 생성할 인스턴스를 가리키는 값이다.
this는 화살표 함수 이전 까지는 함수를 정의할 때 결정되는 것이 아니라 함수가 어떻게 호출되느냐에 따라 동적으로 결정된다. 만약 함수가 일반 함수로서 호출된다면 그 내부의 this는 전역 객체를 가리키게 된다. 그러나 이와 달리 화살표 함수는 함수 자체의 바인딩을 갖지 않는다. 화살표 함수 내부에서 this를 참조하면 상위 스코프의 this를 그대로 따르게 된다.
화살표 함수에서의 this는 우리가 원하는 대로 클래스의 인스턴스인 this를 가리킨다. 즉, 별도의 작업을 추가로 하지 않고 this를 접근할 수 있다.

## 1.2.3 다양한 함수 살펴보기

즉시 실행 함수는 말 그대로 함수를 정의하고 그 순간 즉시 실행되는 함수를 의미한다. 단 한번만 호출되고 다시금 호출할 수 없는 함수
일반적으로 즐시 실행 함수에 이름을 붙이지 않는다.
글로벌 스코프를 오염시키지 않는 독립적인 함수 스코프를 운용할 수 있다는 장점, 다시금 호출되지 않는다는 점에서 리팩터링에도 도움된다.

### 고차 함수
자바스크립트의 함수가 일급 객체라는 특징을 활용하면 함수를 인수로 받거나 결과로 새로운 함수를 반환시킬 수 있다. 이런 역할을 하는 함수를 고차함수라고 한다.


## 1.2.4 함수를 만들 때 주의해야 할 사항
## 함수의 부수 효과(side-effect)를 최대한 억제하라
함수의 부수 효과란 함수 내의 작동으로 인해 함수가 아닌 함수 외부에 영향을 끼치는 것을 의미한다. 이러한 부수 효과가 없는 함수를 순수함수라고 한다. 순수 함수는 언제 어디서나 어떠한 상황에서도 동일한 인수를 받으면 동일한 결과를 반환해야 한다. 이러한 작동 와중에 외부에 어떤 영향도 미쳐서는 안 된다.

## 가능한 한 함수를 작게 만들어라

## 누구나 이해할 수 있는 이름을 붙여라

---
## 1.3 클래스

## 1.3.1 클래스란 무엇인가?
자바스크립트의 클래스란 특정한 객체를 만들기 위한 일종의 템플릿 같은 개념으로 볼 수 있다. 특정한 형태의 객체를 반복적으로 만들기 위해 사용되는 것이 바로 클래스다.

constructor는 생성자로 객체를 생성하는 데 사용하는 특수한 메서드다. 단 하나만 존재할 수 있으며 여러 개를 사용한다면 에러가 발생

프로퍼티란 클래스로 인스턴스를 생성할 때 내부에 정의할 수 있는 속성값을 의미한다.

```
class Car {
	constructor(name) {
	//값을 받으면 내부에 프로퍼티로 할당된다.
		this.name = name;
	}
}
```

const myCar = new Car("자동차") // 프로퍼티로 값을 넘겨주었다.

getter와 setter
getter란 클래스에서 무언가 값을 가져올 때 사용된다. getter를 사용하기 위해서는 get을 앞에 붙여야하고 뒤이어서 getter의 이름을 선언해야 한다.
반대로 setter란 클래스 필드에 값을 할당할 때 사용한다. 마찬가지로 set이라는 키워드를 먼저 선언하고, 그 뒤를 이어서 이름을 붙이면 된다.

인스턴스 메서드
클래스 내부에서 선언한 메서드를 인스턴스 메스드라고 한다. 이 인스턴스 메스드는 실제로 자바스크립트의 prototype의 선언되므로 프로토타입 메스드로 불리기도 한다.

prototype을 확인 할 수 있는 방법은 Object.getPrototypeOf 사용 또는 __proto__
그렇지만 __proto__는 가급적 사용해서는 안되는 코드, 과거 브라우저가 이를 사용했기 때문에 유지되는, 호환성을 지키기 위해서만 존재하는 기능이기 때문


직접 객체에서 선언하지 않았음에도 프로토타입에 있는 메서드를 찾아서 실행을 도와주는 것을 바로 프로토타입 체이닝이라고 한다.
모든 객체는 프로토타입을 가지고 있는데 특정 속성을 찾을 때 까지 자기 자신부터 시작해서 이 프로토타입을 타고 최상위 객체인 Object까지 훑는다.

정적메서드는 특이하게 클래스의 인스턴스가 아닌 이름으로 호출할 수 있는 메서드다.
정적 메서드 내부의 this는 클래스로 생성된 인스턴스가 아닌 클래스 자신을 가리키기 때문에 다른 메서드에서 일반적으로 사용하는 this를 사용할 수 없다.
정적 메서드는 비록 this에 접근할 수 없지만 인스턴스를 생성하지 않아도 사용할 수 있다는 점, 그리고 생성하지 않아도 접근할 수 있기 때문에 객체를 생성하지 않더라도 여러 곳에서 재사용이 가능하다는 장점이 있다.

## 1.3.2  클래스와 함수의 관계
클래스가 작동하는 방식은 자바스크립트의 프로토타입을 활용하는 것

---

## 1.4 클로저
리액트의 클래스형 컴포넌트에 대한 이해가 자바스크립트의 클래스, 컴포넌트, this에 달려있다면 함수형 컴포넌트에 대한 이해는 클로저에 달려 있다.

## 1.4.1
클로저의 정의
클로저는 함수와 함수가 선언된 어휘적 환경의 조합
즉 선언된 어휘적 환경이란 것은 변수가 코드 내부에서 어디서 선언됐는지를 말한다. 호출되는 방식에 따라 동적으로 결정되는 this와는 다르게 코드가 작성된 순간에 정적으로 결정된다. 클로저는 이러한 어휘적 환경을 조합해 코딩하는 기법이다.

## 1.4.2
변수의 유효 범위, 스코프

### 전역 스코프
전역 레벨에서 선언하는 것을 스코프라고 한다.이 스코프에서 변수를 선언하면 어디서든 호출할 수 있게 된다.
브라우저 환경에서 전역 객체는 window, Node.js 환경에서는 global이 있는데 바로 이 객체에 전역 레벨에서 선언한 스코프가 바인딩 된다.

### 함수 스코프
다른 언어와 달리 자바스크립트는 기본적으로 함수 레벨 스코프를 따른다. 즉, {}블록이 스코프 범위를 결정하지 않는다.
자바스크립트에서 스코프는 일단 가장 가까운 스코프에서 변수가 존재하는지를 먼저 확인

## 1.4.3 클로저의 활용

전역 스코프는 어디서든 원하는 값을 꺼내올 수 있따는 장점이 있지만 반대로 이야기하면 누구든 접근할 수 있고 수정할 수 있다는 뜻
리액트가 관리하는 내부 상태 값은 리액트가 별도로 관리하는 클로저 내부에서만 접근할 수 있다.
클로저를 활용하면 전역 스코프의 사용을 막고 개발자가 원하는 정보만 개발자가 원하는 방향으로 노출시킬 수 있따는 장점이 있다.

리액트에서의 클로저
클로저의 원리를 사용하고 있는 대표적인 것 중 하나가 바로 useState

### 1.4.4 주의할 점
클로저를 사용하는 데는 비용이 든다는 것. 클로저는 생성될 때마다 그 선언적 환경을 기억해야 하므로 추가로 비용이 발생
클로저에 꼭 필요한 작업만 남겨두지 않는다면 메모리르 불필요하게 잡아먹는 결과를 야기할 수 있고 마찬가지로 클로저 사용을 적절한 스코프로 가둬두지 않는다면 성능에 악영향을 미친다.

---

## 1.5 이벤트 루프와 비동기 통신의 이해
자바스크립트는 싱글 스레드에서 작동. 즉 기본적으로 자바스크립트는 한 번에 하나의 작업만 동기 방식으로만 처리할 수 있다. 동기란 직렬 방식으로 작업을 처리하는 것, 이 요청이 시작된 이후에는 무조건 응답을 받은 이후에야 비로소 다른 작업을 처리할 수 있다. 그동안 다른 모든 작업은 대기한다. 
반대의 의미인 비동기란 병렬 방식으로 작업을 처리하는 것을 의미. 요청을 시작한 후 이 응답이 오건 말건 상관없이 다음 작업이 이루어지며 따라서 한 번에 여러 작업이 실행될 수 있다

## 1.5.1 싱글 스레드 자바스크립트
프로세서란 프로그램을 구동해 프로그램의 상태가 메모리상에서 실행되는 작업 단위를 의미. 하나의 프로그램에는 하나의 프로세스만이 할당되므로 여러 개의 복잡한 작업을 수행하기 어려웠는데 그래서 탄생한 더 작은 실행 단위가 바로 스레드. 하나의 프로세스에서는 여러 개의 스레드를 만들 수 있고 스레드끼리는 메모리르 공유할 수 있어 여러 가지 작업을 동시에 수행할 수 있다. 이에 따라 프로세스 내부에서 여러 개의 스레드를 활용하면서 동시 다발적인 작업을 처리할 수 있게 된 것

자바스크립트는 왜 싱글 스레드로 설계됐을까?
자바스크립트가 싱글 스레드라는 것은 무엇을 의미할까? 자바스크립트 코드의 실행이 하나의 스레드에서 순차적으로 이루어진다는 것을 의미. 하나의 스레드에서 순차적으로 이루어진다는 것은 코드를 한 줄 한 줄 실행한다는 것을 의미하며 궁극적으로 하나의 작업이 끝나기 전까지는 뒤이은 작업이 실행되지 않는다는 것을 의미한다.
자바스크립트에서 하나의 코드가 실행하는 데 오래 걸리면 뒤이은 코드가 실행되지 않는 다는 것 이러한 자바스크립트의 특징을 "Run-to-completion"이라고 함.
자바스크립트의 모든 코드는 '동기식'으로 한 번에 하나씩 순차적으로 처리됨

자바스크립트에서 비동기 함수를 선언할 때 쓰는 async는 영어로 "asynchronous" 동시에 일어나지 않는 것을 의미. 요청한 즉시 결과가 주어지지 않을 수도 있고, 따라서 응답이 언제 올지도 알 수 없다. 동기식과 다르게 여러 작업을 동시에 수행할 수 있다는 장점이 있다


## 1.5.2
이벤트 루프란? 
이벤트 루프란 자바스크립트 런타임 외부에서 자바스크립트의 비동기 실행을 돕기 위해 만들어진 장치라 볼 수 있음.

호출 스택과 이벤트 루프
호출 스택은 자바스크립트에서 수행해야 할 코드나 함수를 순차적으로 담아두는 스택
호출 스택이 비어 있는지 여부를 확인하는 것이 바로 이벤트 루프
'코드를 실행하는 것'과 '호출 스택이 비어있는지 확인하는 것' 모두가 단일 스레드에서 일어난다는 점. 두 작업은 동시에 일어날 수 없으며 한 스레드에서 순차적으로 일어남

태스크 큐란 실행해야 할 태스크의 집합을 의미한다.
이벤트 루프는 이러한 태스크 큐를 한 개 이상 가지고 있다.
태스크 큐는 자료 구조의 큐가 아니고 set 형태를 띠고 있다.
그 이유는 선택된 큐 중에서 실행 가능한 가장 오래된 태스크를 가져와야 하기 때문. 태스크 큐에서 의미하는 '실행해야 할 태스크'라는 것은 비동기 함수의 콜백 함수나 이벤트 헨들러 등을 의미

이벤트 루프의 역할은 호출 스택에 실행 중인 코드가 있는지 그리고 태스크 큐에 대기 중인 함수가 있는지 반복해서 확인하는 역할을 한다. 호출 스택이 비어있다면 태스크 큐에 대기 중인 작업이 있는지 확인하고 이 작업을 실행 가능한 오래된 것부터 순차적으로 꺼내와서 실행하게 된다. 이 작업 또한 마찬가지로 태스크 큐가 빌 때까지 이루어진다.
비동기 함수는 누가수행하느냐? 자바스크립트 코드가 동기식으로 실행되는 메인 스레드가 아닌 태스크 큐가 할당되는 별도의 스레드에서 수행된다. 이 별도의 스레드에서 태스크 큐에 작업을 할당해 처리하는 것은 브라우저나 Node.js의 역할
즉, 자바스크립트 코드 실행은 싱글 스레드에서 이루어지지만 이러한 외부 Web API 등은 모두 자바스크립트 코드 외부에서 실행되고 콜백이 태스크 큐로 들어가는 것

## 1.5.3
태스크 큐와 마이크로 태스크 큐
이벤트 루프는 하나의 마이크로 태스크 큐를 갖고 있음
마이크로 태스크에는 대표적으로 Promise가 있음. 이 마이크로 태스크 큐는 기존 태스크 큐보다 우선권을 갖는다.
즉, setTimeout과 setInterval은 Promise보다 늦게 실행됨

렌더링은 태스크 큐를 실행하기에 앞서 먼저 마이크로 태스크 큐를 실행하고 이 마이크로 태스크 큐를 실행한 뒤에 렌더링이 일어난다. 각 마이크로 태스크 큐 작업이 끝날 때 마다 한 번씩 렌더링할 기회를 얻게 된다.

자바스크립트 코드를 실행하는 것 이외에 태스크 큐, 이벤트 루프, 마이크로 태스크 큐, 브라우저/Node.js API 등이 적절한 생태계를 이루고 있기 때문에 싱글 스레드로는 불가능한 비동기 이벤트 처리가 가능해진 것.

---

## 1.6 리액트에서 자주 사용하는 자바스크립트 문법
사용자의 다양한 브라우저 환경, 그리고 최신 문법을 작성하고 싶은 개발자의 요구를 해결하기 위해 탄생한 것이 바로 바벨
바벨은 자바스크립트의 최신 문법을 다야한 브라우저에서도 일관적으로 지원할 수 있도록 코드를 트랜스파일한다. 

## 1.6.1 구조분해 할당
배열 또는 객체의 값을 말 그대로 분해해 개별 변수에 즉시 할당하는 것을 의미
주로 어떠한 객체나 배열에서 선언문 없이 즉시 분해해 변수를 선언하고 할당하고 싶을 때 사용

### 배열 구조 분해 할당
useState 함수는 2개 짜리 배열을 반환하는 함수이며 첫 번째 값을 value로 두 번째 값을 setter로 사용 가능, useState가 객체가 아닌 배열을 반환하는 이유는? 객체 구조 분해 할당은 사용하는 쪽에서 원하는 이름으로 변경하는 것이 번거롭지만 배열 구조 분해 할당은 자유롭게 이름을 선언할 수 있기 때문에 배열을 반환하는 것으로 추측

### 객체 구조 분해 할당
말 그대로 객체에서 값을 꺼내온 뒤 할당하는 것을 의미
배열 구조 분해 할당과 달리 객체는 객체 내부 이름으로 꺼내온다는 차이가 있음

객체 구조 분해 할당의 경우 트랜스파일을 거치면 번들링 크기가 상대적으로 크기 때무넹 만약 자신의 웹 애플리케이션 개발 환경이 ES5를 고려해야 하고 또 객체 구조 분해 할당을 자주 쓰지 않는다면 꼭 써야 하는지 검토할 필요가 있다.

## 1.6.2 전개 구문
구조 분해 할당과는 다르게 배열이나 객체, 문자열과 같이 순회할 수 있는 값에 대해 말 그대로 전개해 간결하게 사용할 수 있는 구문

### 배열의 전개 구문
배열 내부에서 ... 배열을 사용하면 해당 배열을 마치 전개하는 것처럼 선언하고 이를 내부 배열에서 활용할 수 있다. 이러한 특징을 활용하면 기존 배열에 영향을 미치지 않고 배열을 복사하는 것도 가능
```
cost arr1 = ["a", "b"]
const arr2 = arr1

arr1 === arr2 //true. 내용이 아닌 참조를 복사하기 때문에 true가 반환
```

```
const arr1 = ["a", "b"]
const arr2 = [...arr1]

arr1 === arr2//false. 실제로 값만 복사됐을 뿐, 참조는 다르므로 false가 반환
```

### 객체의 전개 구문
객체에서도 배열과 비슷하게 사용 가능, 객체를 새로 만들 때 이 전개 구문을 사용할 수 있으며 마찬가지로 객체를 합성하는 데 있어 편리함을 줌
객체 전개 구문에서 순서 중요

전개 구문 또한 트랜스파일한 결과가 단순히 값을 복사하는 배열과는 다르게 객체의 경우 객체의 속성값 및 설명자 확인, 심벌 체크 등 때문에 트렌스파일된 코드가 커진다.

## 1.6.3 객체 초기자
객체를 선언할 때 객체에 넣고자 하는 키와 값을 가지고 있는 변수가 이미 존재한다면 해당 값을 간결하게 넣어줄 수 있는 방식
```
const a = 1
const b = 2

const obj = {
	a,
	b,
}
```
원래대로 라면 a: a 같은 형식으로 작성해야 했었는데 이미 해당 내용으로 선언된 변수가 있따면 위와 같은 형식으로 축약해서 선언하는 것이 가능해진 것

### 1.6.4
Array 프로토타입의 메서드: map, filter, reduce, forEach
map, filter, reduce, JSX 내부에서 배열을 조작해 바로 원하는 JSX 반환하는 특성상 이 3개의 메서드가 괴장히 자주 쓰임 기존의 배열이 값을 건드리지 않고 새로운 값을 만들어 내기 때문에 기존 값이 변경될 염려 없이 안전하게 사용할 수 있음

Array.prototype.map은 인수로 전달받은 배열과 똑같은 길이의 새로운 배열을 반환하는 메서드, 각 아이템을 순회하면서 각 아이템을 콜백으로 연산한 결과로 구성된 새로운 배열을 만들 수 있음.

Array.prototype.filter 메서드는 콜백 함수를 인수로 받는데 이 콜백 함수에서 truthy 조건을 만족하는 경우에만 해당 원소를 반환하는 메서드, 말 그대로 필터링하는 역할
filter의 결과에 따라 원본 배열 길이 이하의 새로운 배열이 반환

Array.protype.reduce는 콜백 함수와 함께 초깃값을 추가로 인수를 받는데 이 초깃값에 따라 배열이나 객체 또는 그 외의 다른 무언가를 반환할 수 있는 메서드
Array.prototype.reduce는 reducer 콜백 함수를 실행하고 이를 초깃값에 누적해 결과를 반환.
```
const arr = [1, 2 , 3 , 4 ,5]
const sum = arr.reduce((result, item) => {
	return result + item
}, 0)
```
0은 reduce의 결과를 누적할 초깃값, reducer 콜백 함수의 첫 번째 인수는 앞서 선언한 초깃값의 현재값, 두 번째 인수는 현재 배열의 아이템

Array.prototype.forEach
콜백 함수를 받아 배열을 순회하면서 단순히 그 콜백 함수를 실행하기만 하는 메서드
```
const arr = [1, 2, 3]
arr.forEach((item) => console.log(item)) //1, 2, 3
```

forEach는 아무런 반환값 없음, 실행되는 순간 에러를 던지거나 프로세스를 종료하지 않는 이상 이를 멈출 수 없음. break, return, 그 무엇을 이용해도 배열 순회를 멈출 수 없음
forEach에 return을 해도 함수의 return이 아닌 콜백 함수의 return으로 간주됨
forEach 내부의 콜백 함수는 무조건 0(n)만큼 실행되므로 코드 작성과 실행 시에 반드시 최적화할 가능성 있는지 검토

## 1.6.5 삼항 조건 연산자
자바스크립트에서 유일하게 3개의 피연산자를 취할 수 있는 문법

---

## 1.7 선택이 아닌 필수, 타입스크립트

## 1.7.1 타입스크립트란?
기존 자바스크립트 문법에 타입을 가미한 것이 바로 타입스크립트
자바스크립트는 기본적으로 동적 타입의 언어이기 때문에 대부분의 에러를 코드를 실행했을 때만 확인할 수 있다는 문제점이 있다. 

타입스크립트에서는 타입 체크를 정적으로 런타임이 아닌 빌드(트랜스파일) 타임에 수행할 수 있게 해줌
```
function test(a: number ,b: number) {
	return a/b
}
```
타입스크립트는 변수에 타입을 설정할 수 있으므로 a 와 b 변수에 number라는 타입을 지정하면 코드를 작성할 때 오직 number만 할당할 수 있게 됨. 런타임 까지 가지 않더라도 코드를 빌드하는 시점에 이미 에러가 발생할 가능성이 있는 코드를 확인할 수 있음

타입스크립트는 자바스크립트의 슈퍼셋일뿐 자바스크립트에서 불가능한 일은 타입스크립트에서도 마찬가지로 불가능
타입스크립트로 작성된 파일(.tx, .tsx)은 결국 자바스크립트로 변환돼서 Node.js나 브라우저 같은 자바스크립트 런타임 환경에서 실행되는 것이 최종 목표이기 때문.

## 1.7.2 리액트 코드를 효과적으로 작성하기 위한 타입스크립트 활용법

### any 대신 unknown을 사용하자
any는 정말 불가피할 때만 사용해야하는 타입 

타입을 단정할 수 없는 경우에는 unknown을 사용하는 것이 좋음
unknown은 모든 값을 할당할 수 있는 이른바 top type으로 어떠한 값도 할당할 수 있음
any와 다르게 이 값을 바로 사용하는 것은 불가능
unknown으로 선언된 변수를 사용하기 위해서는 type narrowing 즉 타입을 원래 의도했던 대로 적절히 좁혀야함
```
function doSomething(callback: unknow) {
	if(typeof callback === 'function'
	callback()
}
	throw new Error('callback은 함수여야 합니다.')
}
```

top type인 unknown과 반대되는 bottom type으로 never가 있음
이 never 타입은 unknown과 반대로 어떠한 타입도 들어올 수 없음을 의미
실제로 어떤식으로 사용? 타입스크립트로 클래스형 컴포넌트를 선언할 때 props는 없지만 state가 존재하는 상황에서 이 빈 props, 정확히는 어떠한 props도 받아들이지 않는다는 뜻으로 사용이 가능

타입 가드를 적극 활용하자
타입을 사용하는 쪽에서는 최대한 타입을 좁히는 것이 좋음
이러한 타입을 좁히는 데 도움을 주는 것이 바로 타입 가드

### instanceof와 typeof
instanceof는 지정한 인스턴스가 특정 클래스의 인스턴스인지 확인할 수 있는 연산자

in
in은 property in object로 사용되는데 주로 어떤 객체에 키가 존재하는지 확인하는 용도로 사용

제네릭
함수나 클래스 내부에서 단일 타입이 아닌 다양한 타입에 대응할 수 있도록 도와주는 도구
제네릭을 사용하면 타이반 다른 비슷한 작업을 하는 컴포넌트를 단일 제네릭 컴포넌트로 선언해 간결하게 작성할 수 있음

제네릭을 하나 이상 사용할 수도 있다. 
```
function multipleGeneric<First, Last>(a1: First, a2:Last):[First, Last] {
	return [a1, a2]
}

const [a, b] = multipleGeneric<string, boolean>('true', true)

a //string
b //boolean
```

### 인덱스 시그니처
인덱스 시그니처란 객체의 키를 정의하는 방식
인덱스 시크니처를 사용하면 키에 원하는 타입을 부요 가능, 키는 동적으로 선언되는 경우를 최대한 지양해야 하고 객체의 타입도 필요에 따라 좁혀야 함

### 객체의 키를 좁히는 방법 2가지

```
//record를 사용
type Hello = Record<'hello', string>

const hello:Hello = {
	hello: 'hello',
	hi: 'hi',
}
```

```
//타입을 사용한 인덱스 시그니처
type Hello = { [Key in 'hello' | 'hi']: string }

const hello: Hello = {
	hello: 'hello',
	hi: 'hi',
}
```

Record<Key, Value>를 사용하면 객체의 타입에 각각 원하는 키와 값을 넣을 수 있음
그리고 인덱스 시그니처에 타입을 사용함으로써 객체를 원하는 형태로 최대한 좁힐 수 있음

## 1.7.3 타입스크립트 전환 가이드

tsconfig.json 먼저 작성하기
타입스크립트로 전환하기 위해 가장 먼저 해야할 것은 타입스크립트를 작성할 수 있는 환경을 만드는 것

JSDoc와 @ts-check를 활용해 점진적으로 전환하기
자바스크립트 파일을 굳이 타입스크립트로 전환하지 않더라도 타입을 체크하는 방법이 있음 파일 최상단에 //@ts-check를 선언하고 JSDoc를 활용해 변수나 함수에 타입을 제공하면 타입스크립트 컴파일러가 자바스크립트 파일의 타입을 확인함

타입 기반 라이브러리 사용을 위해 @types 모듈 설치하기

파일 단위로 조금씩 전환하기
